package gquery

import (
	"bytes"
	"log"
	"os"
	"strings"

	"github.com/andybalholm/cascadia"
	"golang.org/x/net/html"
)

//ROOT is the root of all the elements generated by the text.
var ROOT *html.Node

//Document is an html node, inherited from Elements.
type Document struct {
	Element
}

//Element is a single element that inherits from Elements.
type Element struct {
	Elements
}

//Elements is the foundation.
type Elements struct {
	root  *html.Node
	nodes []*html.Node
}

//NewDocument uses a file to create a Document.
func NewDocument(file string) (*Document, error) {
	doc := new(Document)

	fs, err := os.Open(file)
	if err != nil {
		return nil, err
	}
	defer fs.Close()

	nodes, err := html.ParseFragment(fs, nil)
	if err != nil {
		return nil, err
	}

	doc.nodes = append(doc.nodes, nodes[0])
	doc.root = nodes[0]
	return doc, nil
}

//Render generates text content.
func (e *Elements) Render() string {
	if len(e.nodes) > 0 {
		node := e.nodes[0]
		buf := new(bytes.Buffer)
		html.Render(buf, node)
		return buf.String()
	}
	return ""
}

//Find use the css selector to select elements.
func (e *Elements) Find(query string) *Elements {
	selector, err := cascadia.Compile(query)
	if err != nil {
		log.Panicln(err)
	}

	nodes := make([]*html.Node, 0)
	for _, n := range e.nodes {
		ns := selector.MatchAll(n)
		nodes = append(nodes, ns...)
	}

	return newElements(e.root, nodes)
}

//Each traverse the element and call the callback function.
func (e *Elements) Each(fn func(element *Element), q ...interface{}) {
	if len(q) == 0 {
		for _, n := range e.nodes {
			fn(newElement(e.root, n))
		}
	}
	if len(q) == 1 {
		s, ok := q[0].(string)
		if ok {
			selector, err := cascadia.Compile(s)
			if err != nil {
				log.Panicln(err)
			}

			for _, n := range e.nodes {
				nodes := selector.MatchAll(n)
				for _, node := range nodes {
					fn(newElement(e.root, node))
				}
			}
		}
	}

}

//Lenght return element length.
func (e *Elements) Lenght() int {
	return len(e.nodes)
}

//func (elms *Elements) Selector()
//func (elms *Elements) Context()

//GetNode get the nth *html.Node.
func (e *Elements) GetNode(index int) *html.Node {
	if index < len(e.nodes) {
		return e.nodes[index]
	}
	return nil
}

//GetElement get the nth *Element.
func (e *Elements) GetElement(index int) *Element {
	if index < len(e.nodes) {
		return newElement(e.root, e.nodes[index])
	}
	return nil
}

//Attr get or set attr.
//get. Attr(key string) string
//set. Attr([]string{key, val, key2, val2, ...})
func (e *Elements) Attr(kv interface{}) string {
	switch kv.(type) {
	case string:
		key, _ := kv.(string)
		for _, attr := range e.nodes[0].Attr {
			if attr.Key == key {
				return attr.Val
			}
		}

	case []string:
		kvs, _ := kv.([]string)
		if len(kvs)%2 != 0 {
			log.Panicln("Error in func Element.Attr ([]string) : []string must be a multiple of 2. ")
		}

		l := len(kvs) / 2

		for i := 0; i < l; i++ {
			for _, node := range e.nodes {
				hasAttr := false
				for _, attr := range node.Attr {
					if attr.Key == kvs[i*2] {
						attr.Val = kvs[i*2+1]
						hasAttr = true
						break
					}
				}
				if !hasAttr {
					node.Attr = append(node.Attr, html.Attribute{
						Key: kvs[i*2],
						Val: kvs[i*2+1],
					})
				}
			}
		}
	}

	return ""
}

//RemoveAttr remove attr
func (e *Elements) RemoveAttr(k string) {
	for _, node := range e.nodes {
		for i, attr := range node.Attr {
			if attr.Key == k {
				node.Attr = append(node.Attr[0:i], node.Attr[i+1:]...)
				break
			}
		}
	}
}

//AddClass add class
//func1. AddClass(class string)
//func2. AddClass(func(i int) string)
func (e *Elements) AddClass(c interface{}) {
	switch c.(type) {
	case string:
		c, _ := c.(string)
	l:
		for _, node := range e.nodes {
			for i, attr := range node.Attr {
				if attr.Key == "class" {
					node.Attr[i].Val = node.Attr[i].Val + " " + c
					continue l
				}
			}
			class := html.Attribute{
				Key: "class",
				Val: c,
			}
			node.Attr = append(node.Attr, class)
		}
	case func(i int) string:
		fn, _ := c.(func(i int) string)
	ll:
		for i, node := range e.nodes {
			for ii, attr := range node.Attr {
				if attr.Key == "class" {
					node.Attr[ii].Val = node.Attr[ii].Val + " " + fn(i)
					continue ll
				}
			}
			class := html.Attribute{
				Key: "class",
				Val: fn(i),
			}
			node.Attr = append(node.Attr, class)

		}
	}
}

//RemoveClass rmove class
//func1. RemoveClass(class string)
//func2. RemoveClass(func(i int) string)
func (e *Elements) RemoveClass(c interface{}) {
	switch c.(type) {
	case string:
		c, _ := c.(string)
		for _, node := range e.nodes {
			for i, attr := range node.Attr {
				if attr.Key == "class" {
					vs := strings.Split(attr.Val, " ")
					class := ""
					sep := ""
					for _, v := range vs {
						if v == c {
							continue
						}
						class += sep + v
						sep = " "
					}
					node.Attr[i].Val = class
				}
			}
		}
	case func(i int) string:
		fn, _ := c.(func(i int) string)
		for i, node := range e.nodes {
			for ii, attr := range node.Attr {
				if attr.Key == "class" {
					vs := strings.Split(attr.Val, " ")
					class := ""
					sep := ""
					for _, v := range vs {
						if v == fn(i) {
							continue
						}
						class += sep + v
						sep = " "
					}
					node.Attr[ii].Val = class
				}
			}

		}
	}
}

//ToggleClass toggle class
//func1. ToggleClass(class string)
//func2. ToggleClass(func(i int) string)
func (e *Elements) ToggleClass(c interface{}) {
	switch c.(type) {
	case string:
		c, _ := c.(string)
	l:
		for _, node := range e.nodes {
			for ii, attr := range node.Attr {
				if attr.Key == "class" {
					hasClassVal := false

					vs := strings.Split(attr.Val, " ")
					class := ""
					sep := ""
					for _, v := range vs {
						if v == c {
							hasClassVal = true
							continue
						}
						class += sep + v
						sep = " "
					}
					node.Attr[ii].Val = class
					if !hasClassVal {
						node.Attr[ii].Val = node.Attr[ii].Val + " " + c
					}
					continue l
				}
			}
			class := html.Attribute{
				Key: "class",
				Val: c,
			}
			node.Attr = append(node.Attr, class)
		}
	case func(i int) string:
		fn, _ := c.(func(i int) string)
	ll:
		for i, node := range e.nodes {
			for ii, attr := range node.Attr {
				if attr.Key == "class" {
					hasClassVal := false

					vs := strings.Split(attr.Val, " ")
					class := ""
					sep := ""
					for _, v := range vs {
						if v == fn(i) {
							hasClassVal = true
							continue
						}
						class += sep + v
						sep = " "
					}
					node.Attr[ii].Val = class
					if !hasClassVal {
						node.Attr[ii].Val = node.Attr[ii].Val + " " + fn(i)
					}
					continue ll
				}

			}
			class := html.Attribute{
				Key: "class",
				Val: fn(i),
			}
			node.Attr = append(node.Attr, class)
		}
	}
}

//====================================

//Clone clone Elements
func (e *Elements) Clone() *Elements {
	nodes := make([]*html.Node, 0)
	for _, n := range e.nodes {
		newNode := nodeCopy(n)
		nodes = append(nodes, newNode)
	}

	return newElements(ROOT, nodes)
}

//Wrap wrap element
//func1. Wrap(htmltext string)
//func2. Wrap(node *html.Node)
//func3. Wrap(elements *Elements) . Use only the first element to wrap.
//func4. Wrap(fn func(i int) interface{})
func (e *Elements) Wrap(n interface{}) {
	node := nodeSwitch(n)
	fn, ok := n.(func(i int) interface{})
	if node == nil && ok {
		for i, node := range e.nodes {
			elm := newElements(e.root, []*html.Node{node})
			elm.Wrap(fn(i))
		}
		return
	}
	for _, n := range e.nodes {
		newnode := nodeCopy(node)
		parent := n.Parent
		next := n.NextSibling

		parent.RemoveChild(n)
		parent.InsertBefore(newnode, next)
		newnode.AppendChild(n)
	}
}

//================================

//Text get or set text.
//get. Text() string . Can only get the text of the first element.
//set.
//	func1. Text(t string)
//	func2. Text(func(i int) string)
func (e *Elements) Text(t ...interface{}) string {
	if len(t) == 0 {
		if len(e.nodes) > 0 {
			s := make([]string, 0)
			for n := e.nodes[0].FirstChild; n != nil; n = n.NextSibling {
				if n.Type == html.TextNode {
					d := strings.TrimSpace(n.Data)
					if len(d) > 0 {
						s = append(s, n.Data)
					}
					continue
				}
				if n.FirstChild != nil {
					s = append(s, newElement(e.root, n).Text())
				}
			}
			return strings.Join(s, " ")
		}
	} else if len(t) == 1 {
		switch t[0].(type) {
		case string:
			s, _ := t[0].(string)
			for _, node := range e.nodes {
				for n := node.FirstChild; n != nil; {
					tn := n.NextSibling
					node.RemoveChild(n)
					n = tn
				}

				s = html.EscapeString(s)
				node.AppendChild(nodeNewByString(s))
			}
		case func(i int) string:
			fn, _ := t[0].(func(i int) string)
			for i, node := range e.nodes {
				newElement(e.root, node).Text(fn(i))
			}
		}
	}
	return ""
}

//HTML get or set HTML.
//get. HTML() string . Can only get the text of the first element.
//set.
//	func1. HTML(t string)
//	func2. HTML(func(i int) string)
func (e *Elements) HTML(t ...interface{}) string {
	if len(t) == 0 {
		if len(e.nodes) > 0 {
			buf := new(bytes.Buffer)
			html.Render(buf, e.nodes[0])
			return buf.String()
		}
	} else if len(t) == 1 {
		switch t[0].(type) {
		case string:
			s, _ := t[0].(string)
			for _, node := range e.nodes {
				for n := node.FirstChild; n != nil; {
					tn := n.NextSibling
					node.RemoveChild(n)
					n = tn
				}

				n := nodeNewByString(s)
				node.AppendChild(n)
			}
		case func(i int) string:
			fn, _ := t[0].(func(i int) string)
			for i, node := range e.nodes {
				newElement(e.root, node).HTML(fn(i))
			}
		}
	}
	return ""
}

//=======================================

//After insert an element after the element
//func1. Afte(htmltext string)
//func2. Afte(node *html.Node)
//func3. Afte(elements *Elements)
//func4. Afte(fn func(i int) interface{})
func (e *Elements) After(n interface{}) {
	node := nodeSwitch(n)
	fn, ok := n.(func(i int) interface{})
	if node == nil && ok {
		for i, node := range e.nodes {
			newElement(e.root, node).After(fn(i))
		}
		return
	}

	l := len(e.nodes) - 1
	for i, n := range e.nodes {
		if n == node {
			continue
		}
		new := nodeCopy(node)
		parent := n.Parent
		next := n.NextSibling

		if i == l {
			node.Parent.RemoveChild(node)
			new = node
		}
		parent.InsertBefore(new, next)
	}
}

//Before insert an element Before the element
//func1. Before(htmltext string)
//func2. Before(node *html.Node)
//func3. Before(elements *Elements)
//func4. Before(fn func(i int) interface{})
func (e *Elements) Before(n interface{}) {
	node := nodeSwitch(n)
	fn, ok := n.(func(i int) interface{})
	if node == nil && ok {
		for i, node := range e.nodes {
			newElement(e.root, node).Before(fn(i))
		}
		return
	}

	l := len(e.nodes) - 1
	for i, n := range e.nodes {
		if n == node {
			continue
		}
		new := nodeCopy(node)
		parent := n.Parent

		if i == l {
			node.Parent.RemoveChild(node)
			new = node
		}
		parent.InsertBefore(new, n)
	}
}

//Remove remove the element
//func1. Remove()
//func2. Remove(query string)
func (e *Elements) Remove(n ...interface{}) {
	if len(n) == 0 {
		for _, node := range e.nodes {
			node.Parent.RemoveChild(node)
		}
	} else if len(n) == 1 {
		v, ok := n[0].(string)
		if ok {
			for _, node := range e.nodes {
				newElement(e.root, node).Find(v).Remove()
			}
		}
	}
}

//Append add to the end of the element's child element.
//The original element will be removed and will point to the last added element.
//func1. Append(htmltext string)
//func2. Append(node *html.Node)
//func3. Append(elements *Elements)
func (e *Elements) Append(n interface{}) {
	node := nodeSwitch(n)
	node.Parent.RemoveChild(node)

	l := len(e.nodes) - 1
	for i, n := range e.nodes {
		if n == node {
			continue
		}
		new := nodeCopy(node)
		if i == l {
			new = node
		}
		n.AppendChild(new)
	}
}

//Prepend add to the beginning of the child element of the element.
//The original element will be removed and will point to the last added element.
//func1. Prepend(htmltext string)
//func2. Prepend(node *html.Node)
//func3. Prepend(elements *Elements)
func (e *Elements) Prepend(n interface{}) {
	node := nodeSwitch(n)
	node.Parent.RemoveChild(node)

	l := len(e.nodes) - 1

	for i, n := range e.nodes {
		if n == node {
			continue
		}
		new := nodeCopy(node)
		c := n.FirstChild
		if i == l {
			new = node
		}
		n.InsertBefore(new, c)
	}
}

//ReplaceWith replace the element.
//The original element will be removed and will point to the last added element.
//func1. ReplaceWith(htmltext string)
//func2. ReplaceWith(node *html.Node)
//func3. ReplaceWith(elements *Elements)
func (e *Elements) ReplaceWith(n interface{}) {
	node := nodeSwitch(n)
	node.Parent.RemoveChild(node)

	l := len(e.nodes) - 1
	for i, n := range e.nodes {
		if n == node {
			continue
		}
		new := nodeCopy(node)
		next := n.NextSibling
		if i == l {
			new = node
		}
		n.Parent.RemoveChild(n)
		n.Parent.InsertBefore(new, next)
	}
}

//Next exclude the next element of a blank element.
func (e *Elements) Next() *Elements {
	ns := make([]*html.Node, 0)
	for _, n := range e.nodes {
		next := nodeNext(n)
		if next != nil {
			ns = append(ns, next)
		}
	}
	return newElements(e.root, ns)
}

//Prev exclude the prev element of a blank element.
func (e *Elements) Prev() *Elements {
	ns := make([]*html.Node, 0)
	for _, n := range e.nodes {
		next := nodePrev(n)
		if next != nil {
			ns = append(ns, next)
		}
	}
	return newElements(e.root, ns)
}

//Children get element child elements.
//func1. Children()
//func2. Children(query string)
func (e *Elements) Children(q ...interface{}) *Elements {
	ns := make([]*html.Node, 0)
	for _, node := range e.nodes {
		ns = append(ns, nodeChild(node)...)
	}

	if len(q) == 0 {
		return newElements(e.root, ns)
	} else if len(q) == 1 {
		v, ok := q[0].(string)
		if ok {
			selector, err := cascadia.Compile(v)
			if err != nil {
				log.Panicln(err)
			}
			return newElements(e.root, selector.Filter(ns))
		}
	}
	return nil
}

//Parent get element parent elements.
//func1. Parent()
//func2. Parent(query string)
func (e *Elements) Parent(q ...interface{}) *Elements {
	ns := make([]*html.Node, 0)
l:
	for _, node := range e.nodes {
		p := node.Parent
		for _, n := range ns {
			if p == n {
				continue l
			}
		}
		ns = append(ns, p)
	}

	if len(q) == 0 {
		return newElements(e.root, ns)
	} else if len(q) == 1 {
		v, ok := q[0].(string)
		if ok {
			selector, err := cascadia.Compile(v)
			if err != nil {
				log.Panicln(err)
			}
			return newElements(e.root, selector.Filter(ns))
		}
	}
	return nil
}

//Mul copy multiple copies of an element
func (e *Elements) Mul(i int) *Elements {
	s := e.nodes[0]
	p := s.Parent
	ns := make([]*html.Node, 0)
	ns = append(ns, s)
	for i--; i > 0; i-- {
		n := nodeCopy(s)
		p.AppendChild(n)
		ns = append(ns, n)
	}
	return newElements(e.root, ns)
}
